/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include "xparameters.h"
#include "xaxidma.h"    // AXI DMA driver
#include "xsnn_ip.h"    // HLS SNN IP driver
#include "xil_printf.h"
#include "xil_cache.h"
#include "xuartps_hw.h" // XUartPs_RecvByte
#include <stdint.h>

#define N_INPUT        256
#define NUM_TIMESTEPS  10
#define N_WORDS_IN     (N_INPUT * NUM_TIMESTEPS)   // 2560
#define N_WORDS_OUT    1

#define DMA_DEV_ID     XPAR_AXIDMA_0_DEVICE_ID
#define SNN_DEV_ID     XPAR_SNN_IP_0_DEVICE_ID

// ⚠ UART 베이스 주소 보드마다 다를 수 있음.
// xil_printf 나가는 UART와 같은 걸로 맞춰야 함.
// XPAR_XUARTPS_0_BASEADDR / XPAR_XUARTPS_1_BASEADDR 중 자기 보드에 맞게 확인.
#define UART_BASEADDR  XPAR_XUARTPS_0_BASEADDR

static XAxiDma AxiDma;
static XSnn_ip SnnIp;

// TX: PS -> DMA -> snn_ip.in_stream
// RX: snn_ip.out_stream -> DMA -> PS
static u32 tx_buf[N_WORDS_IN] __attribute__((aligned(64)));
static u32 rx_buf[N_WORDS_OUT] __attribute__((aligned(64)));

void recv_spikes_from_pc(void);

int main()
{
    int status;

    xil_printf("=== SNN FC-last DMA test (PC spikes) ===\r\n");
    xil_printf("Expecting %d spike bytes from PC (T=%d, N_INPUT=%d)\r\n",
               N_WORDS_IN, NUM_TIMESTEPS, N_INPUT);

    // 1) Initialize SNN IP (AXI-Lite control)
    status = XSnn_ip_Initialize(&SnnIp, SNN_DEV_ID);
    if (status != XST_SUCCESS) {
        xil_printf("ERROR: SnnIp init failed\r\n");
        return -1;
    }

    // 2) Initialize AXI DMA
    XAxiDma_Config *CfgPtr = XAxiDma_LookupConfig(DMA_DEV_ID);
    if (!CfgPtr) {
        xil_printf("ERROR: No DMA config found\r\n");
        return -1;
    }

    status = XAxiDma_CfgInitialize(&AxiDma, CfgPtr);
    if (status != XST_SUCCESS) {
        xil_printf("ERROR: DMA init failed\r\n");
        return -1;
    }

    if (XAxiDma_HasSg(&AxiDma)) {
        xil_printf("ERROR: DMA is in SG mode, expected Simple mode\r\n");
        return -1;
    }

    // 3) Receive spikes from PC over UART → fill tx_buf
    recv_spikes_from_pc();

    // Flush caches so DMA sees latest data
    Xil_DCacheFlushRange((UINTPTR)tx_buf, sizeof(tx_buf));
    Xil_DCacheFlushRange((UINTPTR)rx_buf, sizeof(rx_buf));

    // 4) Start S2MM (device → DMA) to receive 1 word (class)
    status = XAxiDma_SimpleTransfer(
        &AxiDma,
        (UINTPTR)rx_buf,
        N_WORDS_OUT * sizeof(u32),
        XAXIDMA_DEVICE_TO_DMA
    );
    if (status != XST_SUCCESS) {
        xil_printf("ERROR: DMA S2MM setup failed\r\n");
        return -1;
    }

    // 5) Start MM2S (DMA → device) to send spikes
    status = XAxiDma_SimpleTransfer(
        &AxiDma,
        (UINTPTR)tx_buf,
        N_WORDS_IN * sizeof(u32),
        XAXIDMA_DMA_TO_DEVICE
    );
    if (status != XST_SUCCESS) {
        xil_printf("ERROR: DMA MM2S setup failed\r\n");
        return -1;
    }

    // 6) Start SNN IP core
    XSnn_ip_Start(&SnnIp);

    // 7) Wait until DMA transfers are done
    while (XAxiDma_Busy(&AxiDma, XAXIDMA_DMA_TO_DEVICE));
    while (XAxiDma_Busy(&AxiDma, XAXIDMA_DEVICE_TO_DMA));

    // Invalidate cache to read result from rx_buf
    Xil_DCacheInvalidateRange((UINTPTR)rx_buf, sizeof(rx_buf));

    // 8) Read predicted class (one word from snn_ip's out_stream)
    int cls = (int)(rx_buf[0] & 0xFF);
    xil_printf("Predicted class = %d\r\n", cls);

    xil_printf("=== Done ===\r\n");
    return 0;
}

// --------------------------------------------------------
// Receive NUM_TIMESTEPS * N_INPUT bytes from PC over UART
// Protocol:
//   PC sends:  'S' 'N' 'N'  (3-byte header)
//              then 2560 bytes of spikes (0 or 1)
// Board:
//   waits header, then reads 2560 bytes and stores to tx_buf
// --------------------------------------------------------
void recv_spikes_from_pc(void)
{
    int idx = 0;

    xil_printf("Waiting for header 'S','N','N' from PC...\r\n");

    // Wait until we see 'S','N','N' sequence
    while (XUartPs_RecvByte(UART_BASEADDR) != 'S');
    while (XUartPs_RecvByte(UART_BASEADDR) != 'N');
    while (XUartPs_RecvByte(UART_BASEADDR) != 'N');

    xil_printf("Header OK. Receiving %d spike bytes...\r\n", N_WORDS_IN);

    while (idx < N_WORDS_IN) {
        u8 b = XUartPs_RecvByte(UART_BASEADDR);  // blocking receive
        tx_buf[idx++] = (u32)(b & 0xFF);         // snn_ip uses lower 8 bits
    }

    xil_printf("Received all spikes from PC (count=%d).\r\n", idx);
}
