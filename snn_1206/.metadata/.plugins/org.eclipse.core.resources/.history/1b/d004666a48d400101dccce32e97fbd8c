#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xaxidma.h"
#include "xil_cache.h"

// If you have an HLS driver header (optional)
// #include "xsnn_ip.h"

// ==========================================
// Configuration
// ==========================================
#define DMA_DEV_ID          XPAR_AXIDMA_0_DEVICE_ID

// Adjust these if you already defined them elsewhere
#define MEM_BASE_ADDR       0x01000000
#define TX_BUFFER_BASE      (MEM_BASE_ADDR + 0x00100000)
#define RX_BUFFER_BASE      (MEM_BASE_ADDR + 0x00300000)

#define T_TIMESTEPS         10
#define N_INPUT             256
#define N_OUTPUT            10

// We send 1 spike per AXI-stream word (1 byte stored in LSB)
#define N_SPIKES            (T_TIMESTEPS * N_INPUT)   // 2560
#define N_WORDS_IN          N_SPIKES                  // 2560 32-bit words
#define N_WORDS_OUT         1                         // one 32-bit result

// ==========================================
// Global variables
// ==========================================
static XAxiDma AxiDma;

static u32 *TxBufferPtr = (u32 *)TX_BUFFER_BASE;
static u32 *RxBufferPtr = (u32 *)RX_BUFFER_BASE;

// UART inbyte prototype (standalone BSP usually provides this)
extern char inbyte(void);

// ==========================================
// Helper: Initialize AXI DMA
// ==========================================
int init_dma(void)
{
    XAxiDma_Config *CfgPtr;
    int Status;

    CfgPtr = XAxiDma_LookupConfig(DMA_DEV_ID);
    if (!CfgPtr) {
        xil_printf("No config found for AXI DMA %d\r\n", DMA_DEV_ID);
        return XST_FAILURE;
    }

    Status = XAxiDma_CfgInitialize(&AxiDma, CfgPtr);
    if (Status != XST_SUCCESS) {
        xil_printf("AXI DMA init failed\r\n");
        return XST_FAILURE;
    }

    // Ensure Scatter-Gather mode is disabled (we use Simple mode)
    if (XAxiDma_HasSg(&AxiDma)) {
        xil_printf("AXI DMA is in SG mode, not supported in this example\r\n");
        return XST_FAILURE;
    }

    return XST_SUCCESS;
}

// ==========================================
// main
// ==========================================
int main()
{
    int Status;

    init_platform();
    xil_printf("=== SNN FC-last DMA test (PC spikes) ===\r\n");

    Status = init_dma();
    if (Status != XST_SUCCESS) {
        xil_printf("DMA init failed. Exiting.\r\n");
        cleanup_platform();
        return XST_FAILURE;
    }

    xil_printf("Using T_TIMESTEPS = %d, N_INPUT = %d, N_SPIKES = %d\r\n",
               T_TIMESTEPS, N_INPUT, N_SPIKES);
    xil_printf("Waiting for spikes from PC over UART...\r\n");

    // ======================================
    // Infinite loop: process many images
    // Each iteration:
    //   1) Wait for header "SNN"
    //   2) Receive 2560 spike bytes
    //   3) Pack to TX buffer (LSB)
    //   4) Run DMA MM2S + S2MM
    //   5) Print predicted class
    // ======================================
    while (1) {
        // ----------------------------------
        // 1) Wait for header "SNN"
        // ----------------------------------
        xil_printf("SNN waiting for header from PC...\r\n");

        char h0, h1, h2;

        // Wait until first 'S' is received
        do {
            h0 = inbyte();
        } while (h0 != 'S');

        // Read next two characters
        h1 = inbyte();
        h2 = inbyte();

        if (h1 != 'N' || h2 != 'N') {
            xil_printf("Bad header received: %c %c (expected 'N' 'N')\r\n", h1, h2);
            // Go back to waiting for a new header
            continue;
        }

        xil_printf("Header OK. Receiving %d spike bytes...\r\n", N_SPIKES);

        // ----------------------------------
        // 2) Receive N_SPIKES bytes from UART
        //    and pack into 32-bit TX buffer
        // ----------------------------------
        for (int i = 0; i < N_SPIKES; i++) {
            unsigned char b = (unsigned char)inbyte();
            // Store spike in the LSB of a 32-bit word
            TxBufferPtr[i] = (u32)b;
        }

        xil_printf("Received all spikes from PC (count=%d).\r\n", N_SPIKES);

        // Flush TX buffer cache before DMA
        Xil_DCacheFlushRange((UINTPTR)TxBufferPtr, N_WORDS_IN * sizeof(u32));
        // Invalidate RX buffer cache before DMA (just in case)
        Xil_DCacheInvalidateRange((UINTPTR)RxBufferPtr, N_WORDS_OUT * sizeof(u32));

        // ----------------------------------
        // 3) Start S2MM (device-to-DMA) for result
        // ----------------------------------
        Status = XAxiDma_SimpleTransfer(
            &AxiDma,
            (UINTPTR)RxBufferPtr,
            N_WORDS_OUT * sizeof(u32),
            XAXIDMA_DEVICE_TO_DMA
        );
        if (Status != XST_SUCCESS) {
            xil_printf("AXI DMA S2MM transfer failed (Status = %d)\r\n", Status);
            continue;
        }

        // ----------------------------------
        // 4) Start MM2S (DMA-to-device) for spikes
        // ----------------------------------
        Status = XAxiDma_SimpleTransfer(
            &AxiDma,
            (UINTPTR)TxBufferPtr,
            N_WORDS_IN * sizeof(u32),
            XAXIDMA_DMA_TO_DEVICE
        );
        if (Status != XST_SUCCESS) {
            xil_printf("AXI DMA MM2S transfer failed (Status = %d)\r\n", Status);
            continue;
        }

        // ----------------------------------
        // 5) Wait for both directions to complete
        // ----------------------------------
        while (XAxiDma_Busy(&AxiDma, XAXIDMA_DMA_TO_DEVICE)) {
            // busy-wait
        }
        while (XAxiDma_Busy(&AxiDma, XAXIDMA_DEVICE_TO_DMA)) {
            // busy-wait
        }

        // Invalidate RX buffer cache so CPU sees updated data
        Xil_DCacheInvalidateRange((UINTPTR)RxBufferPtr, N_WORDS_OUT * sizeof(u32));

        // ----------------------------------
        // 6) Read result from RX buffer
        //     snn_ip writes a 32-bit word, LSB = class index (0~9)
        // ----------------------------------
        int out_class = (int)(RxBufferPtr[0] & 0xFF);

        xil_printf("Predicted class = %d\r\n", out_class);
        xil_printf("---- One sample processed. Ready for next. ----\r\n");
    }

    // We never reach here in this infinite loop design
    cleanup_platform();
    return XST_SUCCESS;
}

